  function [Lx,Lz] = splitLap2DO8(isize,jsize,dx,dz)% function [Lx,Lz] = splitLap2DO8(isize,jsize,dx,dz)%% splitLap2D08 generates an 8th order sparse laplacian operator -% split into x,z components (central differences). No operator info % added in boundary regions where high order one-sided operators% would be required.%% Note : The opeator works on models in loxigonic form, i.e. if%        we start with a 2D model, p(x,z), the model needs to be%        converted into a loxigonic vector before Lx p makes sense.%        (see ViscoAco codes for examples).%%% Input Arguments% -----------------------------------------------------% 1. isize   : number of samples in the i dimension of the 2D%              grid we are computing the laplacian for.%% 2. jsize   : number of samples in the j dimension of the 2D%              grid we are computing the laplacian for.%% 3. dx      : x mesh spacing (i dimension, in meters)%% 4, dz      : z mesh spacing (j dimension, in meters)%%%% Output Variables% -----------------------------------------------------% 1. Lx      : X component of the laplacian (sparse)% % 2. Lz      : Z component of the laplacian (sparse)%%%% By Jonathan Ajo-Franklin (Started 11/14/04)% % [IMPORTANT] % This function and all associated data files included% are free to use and covered under creative commons% attribution/share-alike  2.5 license. This means you can use them% for  anything you like including commercial apps providing that% you  attribute the creation (to me - see below) and you make% derivative  products available under the same license. If you use% them  in a scientific paper or class project please acknowledge% the source  as,    %% [Dr. Jonathan Ajo-Franklin, Lawrence Berkeley National Laboratory]%% For license details see %% http://creativecommons.org/licenses/by-sa/2.5/% calculating number of sparse entries for Lx and LzentCount = ((isize-8)*(jsize-8)*9);matSize  = isize*jsize;% allocating x and z derivative matrices with blank entriesvx = zeros(entCount,3);vz = zeros(entCount,3);% some spacing coefficientsa = isize;b = 2*isize;c = 3*isize;d = 4*isize;% value coefficientsdxsq     = dx*dx;dzsq     = dz*dz;c4x      = -1.0  /(560.0*dxsq);c3x      =  8.0  /(315.0*dxsq);c2x      = -1.0  /(5.0  *dxsq);c1x      =  8.0  /(5.0  *dxsq);c0x      = -205.0/(72.0 *dxsq);c4z      = -1.0  /(560.0*dzsq);c3z      =  8.0  /(315.0*dzsq);c2z      = -1.0  /(5.0  *dzsq);c1z      =  8.0  /(5.0  *dzsq);c0z      = -205.0/(72.0 *dzsq);   % primary loop boundsibound = isize-4;jbound = jsize-4;cx = 1;cz = 1; % creating entriesfor I=5:ibound,     for J=5:jbound         	      % base index          l = (J-1)*isize + I;                    % Lx entries (5 entries)          vx(cx,  1)   = l;          vx(cx,  2)   = l;           vx(cx,  3)   = c0x;          vx(cx+1,1)   = l;          vx(cx+1,2)   = l+1;           vx(cx+1,3)   = c1x;                  vx(cx+2,1)   = l;          vx(cx+2,2)   = l-1;           vx(cx+2,3)   = c1x;           vx(cx+3,1)   = l;          vx(cx+3,2)   = l+2;           vx(cx+3,3)   = c2x;                 vx(cx+4,1)   = l;          vx(cx+4,2)   = l-2;           vx(cx+4,3)   = c2x;           vx(cx+5,1)   = l;          vx(cx+5,2)   = l+3;           vx(cx+5,3)   = c3x;                 vx(cx+6,1)   = l;          vx(cx+6,2)   = l-3;           vx(cx+6,3)   = c3x;           vx(cx+7,1)   = l;          vx(cx+7,2)   = l+4;           vx(cx+7,3)   = c4x;                 vx(cx+8,1)   = l;          vx(cx+8,2)   = l-4;           vx(cx+8,3)   = c4x;           cx=cx+9;                              % Lz entries          vz(cz,1)     = l;          vz(cz,2)     = l;           vz(cz,3)     = c0z;           vz(cz+1,1)   = l;          vz(cz+1,2)   = l+a;           vz(cz+1,3)   = c1z;           vz(cz+2,1)   = l;          vz(cz+2,2)   = l-a;           vz(cz+2,3)   = c1z;           vz(cz+3,1)   = l;          vz(cz+3,2)   = l+b;           vz(cz+3,3)   = c2z;           vz(cz+4,1)   = l;          vz(cz+4,2)   = l-b;           vz(cz+4,3)   = c2z;          vz(cz+5,1)   = l;          vz(cz+5,2)   = l+c;           vz(cz+5,3)   = c3z;           vz(cz+6,1)   = l;          vz(cz+6,2)   = l-c;           vz(cz+6,3)   = c3z;          vz(cz+7,1)   = l;          vz(cz+7,2)   = l+d;           vz(cz+7,3)   = c4z;           vz(cz+8,1)   = l;          vz(cz+8,2)   = l-d;           vz(cz+8,3)   = c4z;          cz=cz+9;               end;end;% converting three column form to true sparse matrixLx   = spconvert(vx);Lz   = spconvert(vz);% adding last element to make sure size conformsLx(isize*jsize,isize*jsize) = 0;Lz(isize*jsize,isize*jsize) = 0;