  function [seis,tarr,s,t,snaps] = ViscoAcoShot(dx,dz,vmod,lmod,xr,zr,freq,...                                                sCnt,xs,zs,dur,srcType,quiet,visual,snapR)% function [seis,tarr,snaps,s,t] = ViscoAcoShot(dx,dz,vmod,lmod,xr,zr,freq,...%                                               xshot,zshot,dur,srcType,snapR,quiet,visual)%% A 2D visco-acoustic wave equation solver :%% ViscoAcoShot is a 2D visco-acoustic wave equation solver, useful for% generating synthetic seismograms and wavefields. See viscoAcoShotExample1.m% for an example of usage. The code uses an explicit% finite-difference solution to the 2nd-order visco-acoustic wave% equation (see below). The scheme is 2nd order accurate in time and 8th order% accurate in space. Both velocity and loss coefficient are allowed% to vary in 2D.%% This code is a bit slow and memory hungry% (explicitly stores several coefficient arrays).%% This code implements a viscoacoustic wave equation of the form%%    d^2 P    d^2 P   1   d^2 P       d P%    ----- +  ----- = --------- +   l ---%    d x^2    d z^2   v^2 d t^2       d t%%    where   P  = pressure%            v  = p-wave velocity%            l  = a loss coefficient%% The loss coefficient, l, simply premultiplies a diffusion term and is% not equivalent to the more popular SLS loss models which are% implemented in terms of memory variables. Note that no density% term is included.%%% The time-step (dt) is computed automatically based on analytic% stability constraints and should always be stable. The dx and dz% values should generally be less than min(lambda)/4 for optimal% dispersion properties but this can be relaxed to ~ min(lambda)/3% if you are willing to tolerate numerical inaccuracy.%% All operations on the wavefield are applied in loxigonic ordering% which allows MATLAB to use fast matrix/vector multiplies in the% inner loop. The downside is that the laplacian operators are% explicitly stored %%% General Comments%  1) Time domain finite-differences (2nd time/ 8th space)%  2) Sponge absorbing boundary condition (10 lambda)%  3) Ricker source wavelet or Sin wavelet %  4) Hard source addition%  5) Inner loop calculated via sparse matrix/vector multiply%     (explicit generation of difference operator matrix)%%% External functions required% ---------------------------------------------------------------% splitLap2D08,  generates 8th order accurate laplacian operator % padFill,       generates a pad for a mesh and fills with bnd vals% createSponge,  creates a cerjan-type sponge filter%% Internal subfunctions % ---------------------------------------------------------------% l2m,           loxigonic to matrix transform% m2l,           matrix to loxigonic transform%%% Input Arguments% -----------------------------------------------------% 1.  dx       = x grid spacing (m)% 2.  dz       = z grid spacing (m)% 3.  vmod     = velocity model (m/s)% 4.  lmod     = loss model% 5.  xr       = receiver x locations (m)% 6.  zr       = receiver z locations (m)% 7.  freq     = center frequency of ricker wavelet (Hz)% 8.  xshot    = x shot location (m)% 9.  zshot    = z shot location (m)% 10. dur      = number of time steps (not real time but # of iterations)% 11. srcType  = 0, ricker%                1, CW (sin)% 11. snapR    = number of time steps between snapshots %               (0 = no snapshots)% 12. quiet    = 0,         information shown on console%                otherwise, silent% 13. visual   = 0,         no snapshot display%                otherwise, snapshot shown every 5 timesteps% % Output Variables% ---------------------------------------------------------% 1.  seis    = seismogram (in matrix form) - time series sampled at (xr,zr)% 2.  tarr    = time vector for samples in seis (s)% 3.  snaps   = cell array of snapshots% 4.  s       = source signal % 5.  t       = times for source signal samples (s)% % % By Jonathan Ajo-Franklin (Started 11/14/04) %% [IMPORTANT] % This function and all associated data files included% are free to use and covered under creative commons% attribution/share-alike  2.5 license. This means you can use them% for  anything you like including commercial apps providing that% you  attribute the creation (to me - see below) and you make% derivative  products available under the same license. If you use% them  in a scientific paper or class project please acknowledge% the source  as,    %% [Dr. Jonathan Ajo-Franklin, Lawrence Berkeley National Laboratory]%% For license details see % % http://creativecommons.org/licenses/by-sa/2.5/% Issues (fixed)% --------------------------------------------------% a) Forgot to square velocities in calc. - fixed% 1. Partial fix for trailing DC effects %          i)  decreased length of leading and trailing force on%              adding the source - i.e. smaller lead-in and trail%              length%          ii) switched to new ricker formulation (from suf2dmod)%% 2. Polished for distribution, some additional documentation%%   % verbosity modedisp('Starting VAMultiShot');% sizing things upxc     = size(vmod,2);zc     = size(vmod,1);minVel = min(min(vmod));maxVel = max(max(vmod));% calculating stability constraintslambda = minVel/(freq*2);       % smallest wavelength% checking for stable spacingif(max([dx,dz]) > (lambda/4))    disp(cat(1,['maxSpat ', num2str(max([dx,dz])),'  > ',num2str(lambda/4)]));    error('Unstable spacings');end;% SHOULD ADD ARGUMENT DIMENSION CHECKING ..!% calculating a stable timestepSConst          = pi/sqrt(2);dt              = (min([dx,dz])/(SConst*maxVel));tsq             = dt*dt;%disp(cat(1,['   dt     = ',num2str(dt)]));% rickerif(srcType==0)          %   % computing the ricker wavelet over a reasonable time    t       = (-(1/freq):dt:(1/freq));   xA      = pi*freq*t;   xx      = xA.*xA;   wavelet = exp(-xx).*(1-(2.*xx));   st      = length(wavelet);% CWelse   t = (0:dur)*dt;   wavelet = sin(2*pi*freq*t);   st = dur;end;s = wavelet;% adding in a 10 wavelength sidepadsidepad = ceil((lambda*10)/dx);truex   = xc + (sidepad*2);truez   = zc + (sidepad*2);% locations for grid nodesxlocSamps = [(-(sidepad)*dx):dx:((xc+sidepad-1)*dx)];zlocSamps = [(-(sidepad)*dz):dz:((zc+sidepad-1)*dz)];xlocSamps2= [0:dx:((xc*dx)-dx)];zlocSamps2= [0:dz:((zc*dz)-dz)];% padding and filling out blanks vmod2 = padFill(sidepad,vmod);lmod2 = padFill(sidepad,lmod);% calculating coefficientsC1 = 1.0./( (1.0./(vmod2.*vmod2.*tsq)) + (lmod2./dt));C2 = ((lmod2./dt) + (2.0./(vmod2.*vmod2.*tsq))).*C1;C3 = (1.0./(vmod2.*vmod2.*tsq)).*C1;% converting matrix maps to vectors for internal multipliesC1      = m2l(C1);C2      = m2l(C2);C3      = m2l(C3);% creating the sparse laplacian matrixtic;[Lx,Lz] = splitLap2DO8(truex,truez,dx,dz);lapTime = toc;    % creating the sponge filtertcoef  = 0.015/2;                             % this is the                                              % exponent used for                                              % the damping zone,                                              % which sometimes needs                                              % to be tuned sponge = createSponge(xc,zc,sidepad,tcoef);sponge2 = m2l(sponge);% Loop over sourcesfor is = 1:sCnt;    xshot  = xs(is);    zshot  = zs(is);%    disp(cat(1,['shot = #',num2str(is)]));% initializing pressure arraysp1 = m2l(zeros(truez,truex));p2 = m2l(zeros(truez,truex));p3 = m2l(zeros(truez,truex));% source index location (with sidepad added)iloc = round(xshot/dx) + sidepad+1;jloc = round(zshot/dz) + sidepad+1;ctime   = 0;snapNum = 1;% calculating source index in loxigonic coordinatesloc   = ((jloc-1)*truex)+iloc;tstart = tic; % for timing% looping over time-stepsfor S=1:dur,            % incrementing total time    tarr(S)=ctime; ctime = ctime + dt;     % displaying the timestep every 50 steps    if(~quiet)      if(mod(S,50)==0) disp(cat(1,['time step = ',num2str(S)])); end;    end;        % adding the source (hard)    if(S<st)  p2(loc) = wavelet(S);           end;           % updating the wavefield     p3  = (C1.*((Lx*p2)+(Lz*p2)))+(C2.*p2) - (C3.*p1);        % recording seismograms - linear interpolation onto receiver set    p2cur     = l2m(p2,truex);    % store each shot gather in 3D array    seis(is,:,S) = interp2(xlocSamps,zlocSamps,p2cur,xr,zr);            % recording snapshots    if(mod(S,snapR)==0)            if(~quiet)                disp(cat(1,['Snapshot # ',num2str(snapNum)]));            end;	                % clipping out sidepad and storing            snaps{snapNum} = p2cur(sidepad+1:(zc+sidepad),sidepad+1:(xc+sidepad));            snapNum = snapNum+1;     end;        % adding aborbing boundary condition    p3 = p3.*sponge2;    p2 = p2.*sponge2;    p1 = p1.*sponge2;        % display output for debugging    if(visual)      if(mod(S,5)==0)	pause(0.01);        subplot(1,2,2);    imagesc(xlocSamps2,zlocSamps2,...		p2cur(sidepad+1:(zc+sidepad),sidepad+1:(xc+sidepad))); 	axis equal; axis tight; hold on;	%plot(xshot,zshot,'ro');	xlabel('X (m)'); ylabel('Depth (m)');	hold off;       end;    end;        % doing grid exchanges    p1 = p2;    p2 = p3;   end;shotTime= toc(tstart);disp(cat(1,['shot #',num2str(is),'  compute time =',num2str(shotTime)]));end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% some sub-functions                                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  function [m] = l2m(vec,jj) % function [m] = l2m(vec,jj)%% This function gets a vector v and retures a matrix with dimensions% length(vec)/jj,jj. The numbers are ordered in loxigonic ordering% This function is the oposite to vc i.e if A is a matrix size ky,kx% then mat(vc(A),kx)=A%N=max(size(vec));ii=N/jj;m=zeros(ii,jj);for i=1:ii,   for j=1:jj,      m(i,j)=vec((i-1)*jj+j);   end;end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  function [v] = m2l(A) % function [v] = m2l(A)%% This function takes a 2-D array and transfoms it into a vector% in loxigonic ordering%% Input:  A - a matrix% Output: v - a vector% [si,sj]=size(A);v=zeros(si*sj,1);for i=1:si,    v((i-1)*sj+1:i*sj)=A(i,:);end;